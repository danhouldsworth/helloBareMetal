#include <avr/interrupt.h>
#include <avr/pgmspace.h>
// #include <util/delay.h>
#include <stdlib.h>
#include "SSD1306.h"
#include "DanUSARTv2.h"

#define ON  1
#define OFF 0

void SSD1306_begin();
void SSD1306_command(uint8_t c);
void SSD1306_data(uint8_t c);
void SSD1306_display(void);
void SSD1306_drawPixel(int16_t x, int16_t y, uint16_t color);
void writeSPI(uint8_t c);
void initHW_SPI(void);
void CSport(uint8_t state);
void DCport(uint8_t state);
void RSTport(uint8_t state);
void displaySPItotal(void);

// the memory buffer for the LCD
static uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
	0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
	0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
	0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
	0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
	0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
	0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
	0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
	0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
	0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
	0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
	0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
	0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
	0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
	0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
	0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
	0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
	0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
	0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
	0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
	0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
	0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
	0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
	0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
	0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
	0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
	0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
	0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// static uint8_t buffer[100];
uint16_t hwSPIbyteCounter = 0;
uint16_t swSPIbyteCounter = 0;
uint8_t reset_toggle = ON;

int main(void){

	initUSART0();
	initPWM(255);

	for(;;){
	}
}

// -- App specific read / output messages & processes
void readFromRxBuffer(){

    if (rcvdPtr == readPtr) return;

    uint8_t u8TempData = *readPtr++;
    if (readPtr > (ringBufferRecv + RING_BUFF_SIZE)) readPtr = ringBufferRecv;  // Wrap the readPtr round the ring

    switch (u8TempData) {
        case '\r':
        case '\n':
        	USART0SendString("\r\n");
        	break;
        case '1':
        	USART0SendString("Confirmed USART init()\r\n");
        	break;
        case '2':
	        USART0SendString("initHW_SPI()...\r\n");
        	initHW_SPI();
        	USART0SendString("done! \r\n");
		displaySPItotal();
        	break;
        case '3':
        case 'r':
        	RSTport(reset_toggle);
        	if (reset_toggle == 1) {
        		reset_toggle = 0;
			USART0SendString("RESET HIGH\r\n");
        	}
        	else if (reset_toggle == 0) {
        		reset_toggle = 1;
			USART0SendString("RESET LOW\r\n");
        	}
        	break;
        case '4':
        	USART0SendString("SSD1306_begin()...\r\n");
        	SSD1306_begin();
        	USART0SendString("done! \r\n");
        	displaySPItotal();
        	break;
        case '5':
        	USART0SendString("SSD1306_display()...\r\n");
        	SSD1306_display();
        	USART0SendString("done! \r\n");
        	displaySPItotal();
        	break;
        case 'l':
        	// for (uint16_t i=0; i<SSD1306_LCDWIDTH; i+=8) writeSPI(buffer[i+row]);
        	// USART0SendString("\r\n");
        	// row++;
        	break;
        case 'd':
        	SSD1306_data(255);
        	displaySPItotal();
        	break;
        case 'c':
        	SSD1306_command(255);
        	displaySPItotal();
        	break;
        // default:
        	// USART0QueueByte(u8TempData);
    }
}
// --

void displaySPItotal(){
    char maxStr[100];
    sprintf(maxStr, "Cumulative bytes sent on SPI = %d\r\n", hwSPIbyteCounter);
    USART0SendString(maxStr);       // Careful : we're sending a pointer to the stack....
}

void CSport(uint8_t state){
	if (state == ON) {
		PORTC |=  (1 << PORTC1);
		// USART0SendString("CS1\r\n");
	}
	else if (state == OFF) {
		PORTC &= ~(1 << PORTC1);
		// USART0SendString("CS0\r\n");
	}
	else USART0SendString("CS BUG!\r\n");
}
void DCport(uint8_t state){
	if (state == ON){
		PORTC |=  (1 << PORTC2);
		// USART0SendString("D/C1\r\n");
	}
	else if (state == OFF){
		PORTC &= ~(1 << PORTC2);
		// USART0SendString("D/C0\r\n");
	}
	else USART0SendString("DC BUG!\r\n");
}
void RSTport(uint8_t state){
	if (state == ON) {
		PORTC |=  (1 << PORTC3);
		// USART0SendString("RST1\r\n");
	}
	else if (state == OFF) {
		PORTC &= ~(1 << PORTC3);
		// USART0SendString("RST0\r\n");
	}
	else USART0SendString("RESET BUG!\r\n");
}

void SSD1306_drawPixel(int16_t x, int16_t y, uint16_t color) {
	if ((x < 0) || (x >= SSD1306_LCDWIDTH) || (y < 0) || (y >= SSD1306_LCDHEIGHT)) return;
	else switch (color){
		case WHITE:   buffer[x+ (y/8)*SSD1306_LCDWIDTH] |=  (1 << (y&7)); break;
		case BLACK:   buffer[x+ (y/8)*SSD1306_LCDWIDTH] &= ~(1 << (y&7)); break;
		case INVERSE: buffer[x+ (y/8)*SSD1306_LCDWIDTH] ^=  (1 << (y&7)); break;
	}
}

void SSD1306_begin(){
	SSD1306_command(SSD1306_DISPLAYOFF);
	SSD1306_command(SSD1306_SETDISPLAYCLOCKDIV);	SSD1306_command(0x80);
	SSD1306_command(SSD1306_SETMULTIPLEX);		SSD1306_command(0x3F);
	SSD1306_command(SSD1306_SETDISPLAYOFFSET);	SSD1306_command(0x0);
	SSD1306_command(SSD1306_SETSTARTLINE | 0x0);
	SSD1306_command(SSD1306_CHARGEPUMP);		SSD1306_command(0x10); // disable
	SSD1306_command(SSD1306_MEMORYMODE);		SSD1306_command(0x00);
	SSD1306_command(SSD1306_SEGREMAP | 0x1);
	SSD1306_command(SSD1306_COMSCANDEC);
	SSD1306_command(SSD1306_SETCOMPINS);		SSD1306_command(0x12);
	SSD1306_command(SSD1306_SETCONTRAST); 		SSD1306_command(0x9F);
	SSD1306_command(SSD1306_SETPRECHARGE);		SSD1306_command(0x22);

	SSD1306_command(SSD1306_SETVCOMDETECT);		SSD1306_command(0x40);
	SSD1306_command(SSD1306_DEACTIVATE_SCROLL);
	SSD1306_command(SSD1306_DISPLAYALLON_RESUME);
	SSD1306_command(SSD1306_NORMALDISPLAY);
	SSD1306_command(SSD1306_DISPLAYON);
}

void SSD1306_command(uint8_t c) {
	CSport(ON);
	DCport(OFF);
	CSport(OFF);
	writeSPI(c);
	CSport(ON);
}

void SSD1306_data(uint8_t c) {
	CSport(ON);
	DCport(ON);
	CSport(OFF);
	writeSPI(c);
	CSport(ON);
}

void SSD1306_display(void) {
	SSD1306_command(SSD1306_COLUMNADDR);
	SSD1306_command(0);   			// Column start address (0 = reset)
	SSD1306_command(SSD1306_LCDWIDTH-1); 	// Column end address (127 = reset)

	SSD1306_command(SSD1306_PAGEADDR);
	SSD1306_command(0); 			// Page start address (0 = reset)
	SSD1306_command(7); 			// Page end address

	CSport(ON);
	DCport(ON);
	CSport(OFF);
	for (uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) writeSPI(buffer[i]);
	CSport(ON);
}
void initHW_SPI(){
	//	CS 		DC 		RST
	DDRC |= (1 << DDC1) | 	(1 << DDC2) | 	(1 << DDC3); 		// GPIO pins to control OLED slave
	PORTC = 1 << PORTC3; // Try and leave reset to manual
	// PRR &= ~(1<<PRSPI);  // clear the power down bit
	/* Set MOSI, SCK & SS as output and leave High*/
	//  	MOSI  		SCK 		SS
	DDRB |=	(1 << DDB3) | 	(1 << DDB5) | 	(1 << DDB2);   		// NOTE!! SPI will hang if SS not set as output
	PORTB = (1 << PORTB3)| 	(1 << PORTB5);//| 	(1 << PORTB2); 	// But doesn't seem to care if set low or high

	/* Enable SPI, Master, set clock rate fck/16 */
	SPCR = (0 << SPIE) | (1 << SPE) | (1 << MSTR) | (0 << SPR1) | (0 << SPR0) | (0 << CPOL) | (0 << CPHA);
}
void swSPI(uint8_t cData){
    for(uint8_t bit = 0x80; bit; bit >>= 1) {
      PORTB &= ~(1<<PORTB5); 	// Clk off
      if(cData & bit) 	PORTB |=  (1<<PORTB3);
      else        	PORTB &= ~(1<<PORTB3);
      PORTB |= (1<<PORTB5); 	// Clk on
    }
}
void uartSPI(uint8_t cData){
    for(uint8_t bit = 0x80; bit; bit >>= 1) {
      if(cData & bit) 	USART0QueueByte('.');
      else        	USART0QueueByte(' ');
    }
}
uint8_t hwSPI(uint8_t cData){
	/* Start transmission */
	cli();
	SPDR = cData;
	while(!(SPSR & (1<<SPIF)));
	sei();
	hwSPIbyteCounter++;
	return 0;
	// return  SPDR; // Clear the SPIF by reading SPDR
}
void writeSPI(uint8_t cData){
	// swSPI(cData);
	hwSPI(cData);
	// uartSPI(cData);
}
// ISR(SPI_STC_vect){}
